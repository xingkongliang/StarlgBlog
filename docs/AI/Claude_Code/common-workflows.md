---
sidebar_position: 5
---

# 常见工作流程

> 了解 Claude Code 的常见工作流程。

本文档中的每个任务都包含清晰的说明、示例命令和最佳实践，以帮助您充分利用 Claude Code。

## 理解新代码库

### 快速了解代码库概览

假设您刚刚加入一个新项目，需要快速了解其结构。

#### 1. 导航到项目根目录
```bash
cd /path/to/project 
```

#### 2. 启动 Claude Code
```bash
claude 
```

#### 3. 请求高级概述
```
> 给我这个代码库的概述
```

#### 4. 深入了解特定组件
```
> 解释这里使用的主要架构模式
```

```
> 关键数据模型是什么？
```

```
> 身份验证是如何处理的？
```

> **提示:**
>
> * 从广泛的问题开始，然后缩小到特定领域
> * 询问项目中使用的编码约定和模式
> * 请求项目特定术语的词汇表

### 查找相关代码

假设您需要定位与特定功能相关的代码。

#### 1. 让 Claude 查找相关文件
```
> 找到处理用户身份验证的文件
```

#### 2. 获取组件如何交互的上下文
```
> 这些身份验证文件是如何协同工作的？
```

#### 3. 理解执行流程
```
> 追踪从前端到数据库的登录过程
```

> **提示:**
>
> * 具体说明您要查找的内容
> * 使用项目中的领域语言

***

## 高效修复错误

假设您遇到了一个错误消息，需要找到并修复其来源。

#### 1. 与 Claude 分享错误
```
> 我在运行 npm test 时看到了一个错误
```

#### 2. 请求修复建议
```
> 建议几种修复 user.ts 中 @ts-ignore 的方法
```

#### 3. 应用修复
```
> 更新 user.ts 以添加您建议的空值检查
```

> **提示:**
>
> * 告诉 Claude 重现问题的命令并获取堆栈跟踪
> * 提及重现错误的任何步骤
> * 让 Claude 知道错误是间歇性的还是持续性的

***

## 重构代码

假设您需要更新旧代码以使用现代模式和实践。

#### 1. 识别需要重构的旧代码
```
> 在我们的代码库中查找已弃用的 API 用法
```

#### 2. 获取重构建议
```
> 建议如何重构 utils.js 以使用现代 JavaScript 功能
```

#### 3. 安全地应用更改
```
> 重构 utils.js 以使用 ES2024 功能，同时保持相同的行为
```

#### 4. 验证��构
```
> 为重构后的代码运行测试
```

> **提示:**
>
> * 让 Claude 解释现代方法的好处
> * 需要时请求更改保持向后兼容性
> * 以小的、可测试的增量进行重构

***

## 使用测试

假设您需要为未覆盖的代码添加测试。

#### 1. 识别未经测试的代码
```
> 在 NotificationsService.swift 中查找未被测试覆盖的函数
```

#### 2. 生成测试脚手架
```
> 为通知服务添加测试
```

#### 3. 添加有意义的测试用例
```
> 为通知服务中的边缘条件添加测试用例
```

#### 4. 运行和验证测试
```
> 运行新测试并修复任何失败
```

> **提示:**
>
> * 请求覆盖边缘情况和错误条件的测试
> * 适当时请求单元测试和集成测试
> * 让 Claude 解释测试策略

***

## 创建拉取请求

假设您需要为您的更改创建一个文档齐全的拉取请求。

#### 1. 总结您的更改
```
> 总结我对身份验证模块所做的更改
```

#### 2. 使用 Claude 生成 PR
```
> 创建一个 pr
```

#### 3. 审查和完善
```
> 增强 PR 描述，提供有关安全改进的更多上下文
```

#### 4. 添加测试细节
```
> 添加有关如何测试这些更改的信息
```

> **提示:**
>
> * 直接让 Claude 为您创建 PR
> * 在提交前审查 Claude 生成的 PR
> * 让 Claude 突出潜在的风险或考虑因素

## 处理文档

假设您需要为您的代码添加或更新文档。

#### 1. 识别未文档化的代码
```
> 在 auth 模块中查找没有正确 JSDoc 注释的函数
```

#### 2. 生成文档
```
> 为 auth.js 中未文档化的函数添加 JSDoc 注释
```

#### 3. 审查和增强
```
> 使用更多上下文和示例改进生成的文档
```

#### 4. 验证文档
```
> 检查文档是否符合我们的项目标准
```

> **提示:**
>
> * 指定您想要的文档样式（JSDoc、docstrings 等）
> * 在文档中请求示例
> * 请求公共 API、接口和复杂逻辑的文档

***

## 使用图像

假设您需要在代码库中使用图像，并且希望 Claude 帮助分析图像内容。

#### 1. 向对话中添加图像
您可以使用以下任何一种方法：

1.  将图像拖放到 Claude Code 窗口中
2.  复制图像并使用 ctrl+v 粘贴到 CLI 中（不要使用 cmd+v）
3.  向 Claude 提供图像路径。例如，“分析此图像：/path/to/your/image.png”

#### 2. 让 Claude 分析图像
```
> 这张图片显示了什么？
```

```
> 描述此屏幕截图中的 UI 元素
```

```
> 此图表中是否有任何有问题的元素？
```

#### 3. 使用图像作为上下文
```
> 这是错误的屏幕截图。是什么原因造成的？
```

```
> 这是我们当前的数据库架构。我们应该如何为新功能修改它？
```

#### 4. 从视觉内容中获取代码建议
```
> 生成 CSS 以匹配此设计模型
```

```
> 什么 HTML 结构可以重现此组件？
```

> **提示:**
>
> * 当文本描述不清楚或繁琐时使用图像
> * 包括错误、UI 设计或图表的屏幕截图以获得更好的上下文
> * 您可以在对话中处理多个图像
> * 图像分析适用于图表、屏幕截图、模型等

***

## 引用文件和目录

使用 @ 快速包含文件或目录，而无需等待 Claude 读取它们。

#### 1. 引用单个文件
```
> 解释 @src/utils/auth.js 中的逻辑
```

这会将文件的全部内容包含在对话中。

#### 2. 引用目录
```
> @src/components 的结构是什么？
```

这会提供一个包含文件信息的目录列表。

#### 3. 引用 MCP 资源
```
> 给我看 @github:repos/owner/repo/issues 的数据
```

这会使用 `@server:resource` 格式从连接的 MCP 服务器获取数据。有关详细信息，��参阅 [MCP 资源](/en/docs/claude-code/mcp#use-mcp-resources)。

> **提示:**
>
> * 文件路径可以是相对路径或绝对路径
> * @ 文件引用会将文件目录及其父目录中的 CLAUDE.md 添加到上下文中
> * 目录引用显示文件列表，而不是内容
> * 您可以在一条消息中引用多个文件（例如，“@file1.js 和 @file2.js”）

***

## 使用扩展思维

假设您正在处理复杂的架构决策、具有挑战性的错误或规划需要深入推理的多步骤实施。

#### 1. 提供上下文并让 Claude 思考
```
> 我需要为我们的 API 实现一个新的使用 OAuth2 的身份验证系统。深入思考在我们的代码库中实现这一点的最佳方法。
```

Claude 将从您的代码库中收集相关信息并使用扩展思维，这将在界面中可见。

#### 2. 通过后续提示完善思考
```
> 思考这种方法中潜在的安全漏洞
```

```
> 更深入地思考我们应该处理的边缘情况
```

> **提示:**
> 要从扩展思维中获得最大价值：
>
> 扩展思维对于复杂任务最有价值，例如：
>
> *   规划复杂的架构更改
> *   调试复杂的问题
> *   为新功能创建实施计划
> *   理解复杂的代码库
> *   评估不同方法之间的权衡
>
> 您提示思考的方式会导致不同程度的思考深度：
>
> *   “思考”会触发基本的扩展思维
> *   “想更多”、“想很多”、“更努力地想”或“想更久”等强化短语会触发更深入的思考
>
> 有关更多扩展思维提示，请参阅[扩展思维提示](/en/docs/build-with-claude/prompt-engineering/extended-thinking-tips)。

> **注意:**
> Claude 会在响应上方以斜体灰色文本显示其思考过程。

***

## 恢复以前的对话

假设您一直在使用 Claude Code 处理一项任务，并需要在以后的会话中从上次中断的地方继续。

Claude Code 提供了两个用于恢复以前对话的选项：

*   `--continue` 自动继续最近的对话
*   `--resume` 显示对话选择器

#### 1. 继续最近的对话
```bash
claude --continue
```

这会立即恢复您最近的对话，无需任何提示。

#### 2. 在非交互模式下继续
```bash
claude --continue --print "继续我的任务"
```

将 `--print` 与 `--continue` 结合使用，以在非交互模式下恢复最近的对话，非常适合脚本或自动化。

#### 3. 显示对话选择器
```bash
claude --resume
```

这将显示一个交互式对话选择器，显示：

*   对话开��时间
*   初始提示或对话摘要
*   消息计数

使用箭头键导航并按 Enter 选择对话。

> **提示:**
>
> *   对话历史记录存储在您的本地计算机上
> *   使用 `--continue` 快速访问您最近的对话
> *   当您需要选择特定的过去对话时使用 `--resume`
> *   恢复时，您将在继续之前看到整个对话历史记录
> *   恢复的对话使用与原始对话相同的模型和配置开始
>
> **工作原理:**
>
> 1.  **对话存储**: 所有对话及其完整的消息历史记录都会自动保存在本地
> 2.  **消息反序列化**: 恢复时，将恢复整个消息历史记录以保持上下文
> 3.  **工具状态**: 保留先前对话中的工具使用情况和结果
> 4.  **上下文恢复**: 对话在恢复时会保留所有先前的上下文
>
> **示例:**
>
> ```bash
> # 继续最近的对话
> claude --continue
>
> # 使用特定提示继续最近的对话
> claude --continue --print "向我展示我们的进展"
>
> # 显示对话选择器
> claude --resume
>
> # 在非交互模式下继续最近的对话
> claude --continue --print "再次运行测试"
> ```

***

## 使用 Git worktrees 运行��行的 Claude Code 会话

假设您需要同时处理多个任务，并且 Claude Code 实例之间具有完全的代码隔离。

#### 1. 了解 Git worktrees
Git worktrees 允许您将同一存储库的多个分支检出到不同的目录中。每个 worktree 都有其自己的工作目录和隔离的文件，同时共享相同的 Git 历史记录。在[官方 Git worktree 文档](https://git-scm.com/docs/git-worktree)中了解更多信息。

#### 2. 创建一个新的 worktree
```bash
# 使用新分支创建一个新的 worktree
git worktree add ../project-feature-a -b feature-a

# 或者使用现有分支创建一个 worktree
git worktree add ../project-bugfix bugfix-123
```

这会创建一个新目录，其中包含您存储库的单独工作副本。

#### 3. 在每个 worktree 中运行 Claude Code
```bash
# 导航到您的 worktree
cd ../project-feature-a

# 在此隔离环境中运行 Claude Code
claude
```

#### 4. 在另一个 worktree 中运行 Claude
```bash
cd ../project-bugfix
claude
```

#### 5. 管理您的 worktrees
```bash
# 列出所有 worktrees
git worktree list

# 完成后删除一个 worktree
git worktree remove ../project-feature-a
```

> **提示:**
>
> *   每个 worktree 都有其自己独立的文件状态，非常适合并行的 Claude Code 会话
> *   在���个 worktree 中所做的更改不会影响其他 worktree，从而防止 Claude 实例相互干扰
> *   所有 worktree 共享相同的 Git 历史记录和远程连接
> *   对于长时间运行的任务，您可以让 Claude 在一个 worktree 中工作，而您在另一个 worktree 中继续开发
> *   使用描述性的目录名称可以轻松识别每个 worktree 对应的任务
> *   请记住根据您的项目设置在每个新的 worktree 中初始化您的开发环境。根据您的技术栈，这可能包括：
>     *   JavaScript 项目：运行依赖项安装（`npm install`、`yarn`）
>     *   Python 项目：设置虚拟环境或使用包管理器安装
>     *   其他语言：遵循您项目的标准设置过程

***

## 将 Claude 用作 unix 风格的实用程序

### 将 Claude 添加到您的验证过程中

假设您想将 Claude Code 用作 linter 或代码审查器。

**将 Claude 添加到您的构建脚本中：**

```json
// package.json
{
    ...
    "scripts": {
        ...
        "lint:claude": "claude -p '你是一个 linter。请查看与 main 的更改并报告任何与拼写错误相关的问题。在一行中报告文件名和行号，在第二行中报告问题的描述。不要返回任何其他文本。'"
    }
}
```

> **提示:**
>
> *   在您的 CI/CD 管道中使用 Claude 进行自动化代码审查
> *   自定义提示以检查与您的项目相关的特定问题
> *   考虑为不同类型的验证创建多个脚本

### 管道输入，管道输出

假设您想将数据通过管道输入到 Claude，并以结构化格式取回数据。

**通过 Claude 管道传输数据：**

```bash
cat build-error.txt | claude -p '简明扼要地解释此构建错误的根本原因' > output.txt
```

> **提示:**
>
> *   使用管道将 Claude 集成到现有的 shell 脚本中
> *   与其他 Unix 工具结合使用以实现强大的工作流程
> *   考虑使用 --output-format 以获得结构化输出

### 控制输出格式

假设您需要 Claude 的输出采用特定格式，尤其是在将 Claude Code 集成到脚本或其他工具中时。

#### 1. 使用文本格式（默认）
```bash
cat data.txt | claude -p '总结这些数据' --output-format text > summary.txt
```

这仅输出 Claude 的纯文本响应（默认行为）。

#### 2. 使用 JSON 格式
```bash
cat code.py | claude -p '分析此代码中的错误' --output-format json > analysis.json
```

这会输出一个包含元数据（包括成本和持续时间）的消息的 JSON 数组。

#### 3. 使用流式 JSON 格���
```bash
cat log.txt | claude -p '解析此日志文件中的错误' --output-format stream-json
```

这会在 Claude 处理请求时实时输出一系列 JSON 对象。每个消息都是一个有效的 JSON 对象，但如果连接起来，整个输出不是有效的 JSON。

> **提示:**
>
> *   当您只需要 Claude 的响应时，使用 `--output-format text` 进行简单集成
> *   当您需要完整的对话日志时，使用 `--output-format json`
> *   当您需要每个对话回合的实时输出时，使用 `--output-format stream-json`

***

## 创建自定义斜杠命令

Claude Code 支持自定义斜杠命令，您可以创建这些命令来快速执行特定的提示或任务。

有关更多详细信息，请参阅[斜杠命令](/en/docs/claude-code/slash-commands)参考页面。

### 创建项目特定的命令

假设您想为您的项目创建可重用的斜杠命令，以便所有团队成员都可以使用。

#### 1. 在您的项目中创建一个命令目录
```bash
mkdir -p .claude/commands
```

#### 2. 为每个命令创建一个 Markdown 文件
```bash
echo "分析此代码的性能并提出三个具体的优化建议���" > .claude/commands/optimize.md 
```

#### 3. 在 Claude Code 中使用您的自定义命令
```
> /project:optimize 
```

> **提示:**
>
> *   命令名称派生自文件名（例如，`optimize.md` 变为 `/project:optimize`）
> *   您可以在子目录中组织命令（例如，`.claude/commands/frontend/component.md` 变为 `/project:frontend:component`）
> *   克隆存储库的每个人都可以使用项目命令
> *   调用命令时，Markdown 文件的内容将成为发送给 Claude 的提示

### 使用 \$ARGUMENTS 添加命令参数

假设您想创建可以接受用户额外输入的灵活斜杠命令。

#### 1. 创建一个带有 $ARGUMENTS 占位符的命令文件
```bash
echo "查找并修复问题 #$ARGUMENTS。请按照以下步骤操作：1.
理解工单中描述的问题 2. 在我们的代码库中定位相关代码 3.
实施解决根本原因的方案 4. 添加适当的测试 5. 准备一份简洁的 PR
描述" > .claude/commands/fix-issue.md 
```

#### 2. 使用带有问题编号的命令
在您的 Claude 会话中，使用带有参数的命令。

```
> /project:fix-issue 123 
```

这会将提示中的 \$ARGUMENTS 替换为 "123"。

> **提示:**
>
> *   \$ARGUMENTS 占位符会被命令后的任何文本替换
> *   您可以将 \$ARGUMENTS 放置在命令模板中的任何位置
> *   其他有用的应用：为特定函数生成测试用例、为组件创建文档、审查特定文件中的代码或将内容翻译成指定语言

### 创建个人斜杠命令

假设您想创建可在所有项目中使用的个人斜杠命令。

#### 1. 在您的主文件夹中创建一个命令目录
```bash
mkdir -p ~/.claude/commands 
```

#### 2. 为每个命令创建一个 Markdown 文件
```bash
echo "审查此代码的安全漏洞，重点关注：" >
~/.claude/commands/security-review.md 
```

#### 3. 使用您的个人自定义命令
```
> /user:security-review 
```

> **提示:**
>
> *   个人命令的前缀是 `/user:` 而不是 `/project:`
> *   个人命令仅对您可用，不与您的团队共享
> *   个人命令可在您的所有项目中工作
> *   您可以将其用于跨不同代码库的一致工作流程

***

## 下一步

[**Claude Code 参考实现**](https://github.com/anthropics/claude-code/tree/main/.devcontainer)

克隆我们的开发容器参考实现。